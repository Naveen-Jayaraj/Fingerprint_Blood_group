<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fingerprint Blood Group AI ðŸ©¸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Set initial theme based on localStorage or system preference
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-x: hidden; /* Prevent horizontal scroll if cards go off edge slightly */
        }
        /* Light Theme Variables (Minimalist) */
        :root {
            --bg-primary: #f8f9fa; /* Very light gray */
            --bg-secondary: #ffffff; /* White */
            --text-primary: #212529; /* Near black */
            --text-secondary: #6c757d; /* Medium gray */
            --accent-primary: #495057; /* Dark gray */
            --accent-secondary: #e9ecef; /* Lighter gray */
            --border-color: #dee2e6; /* Light gray border */
            --border-dashed: #adb5bd; /* Medium gray dashed */
            --shadow-color: rgba(0, 0, 0, 0.05);
        }
        /* Dark Theme Variables (AMOLED Black Minimalist) */
        .dark {
            --bg-primary: #000000; /* AMOLED Black */
            --bg-secondary: #111111; /* Very dark gray */
            --text-primary: #e9ecef; /* Light gray */
            --text-secondary: #adb5bd; /* Medium gray */
            --accent-primary: #dee2e6; /* Light gray */
            --accent-secondary: #343a40; /* Darker gray */
            --border-color: #495057; /* Dark gray border */
            --border-dashed: #6c757d; /* Medium gray dashed */
            --shadow-color: rgba(255, 255, 255, 0.1);
        }
        .content-section {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            padding: 2rem;
            border: 1px solid var(--border-color);
        }
         .dark .content-section {
             background-color: var(--bg-primary);
             border: 1px solid var(--border-color);
         }

        #howItWorksGrid {
            position: relative; /* Crucial for absolute positioning of children */
        }

        .file-upload-wrapper {
            border: 2px dashed var(--border-dashed);
            background-color: transparent;
            color: var(--text-secondary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            cursor: pointer;
            padding: 2rem;
        }
        .file-upload-wrapper:hover {
            border-color: var(--accent-primary);
            background-color: var(--accent-secondary);
             color: var(--text-primary);
        }
         .dark .file-upload-wrapper:hover {
              background-color: var(--bg-secondary);
         }
        input[type="file"] { display: none; }

        button {
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            transition: background-color 0.3s ease, transform 0.1s ease;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 500;
        }
         .dark button {
             color: var(--bg-primary);
         }
        button:hover {
            filter: brightness(115%);
        }
         .dark button:hover {
             filter: brightness(125%);
         }
        button:active {
            transform: translateY(1px);
        }
        button:disabled {
            filter: grayscale(80%);
            opacity: 0.4;
            cursor: not-allowed;
            background-color: var(--accent-secondary);
        }
         .dark button:disabled {
              background-color: var(--accent-secondary);
         }

        #result span {
            display: inline-block;
            background-color: var(--accent-secondary);
            color: var(--accent-primary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 1.25rem;
        }
         .dark #result span {
             border: 1px solid var(--border-color);
             color: var(--text-primary);
         }

        #messageBox { font-size: 0.9rem; border-radius: 0.375rem; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
        .dark .error { background-color: #2c1a1d; color: #f8d7da; border-color: #721c24;}
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb;}
        .dark .success { background-color: #1a301d; color: #d4edda; border-color: #155724;}
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb;}
        .dark .info { background-color: #1a2f33; color: #d1ecf1; border-color: #0c5460;}

        .loader {
            width: 16px; height: 16px; border: 2px solid currentColor; border-bottom-color: transparent;
            border-radius: 50%; display: inline-block; box-sizing: border-box;
            animation: rotation 1s linear infinite; margin-left: 8px;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Smooth theme transition */
        html, body, .content-section, .about-card, input, button, #result span, .file-upload-wrapper, label, h1, h2, p, a, svg, summary {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, fill 0.3s ease, box-shadow 0.3s ease;
        }
        .about-section h2 {
            font-size: 1.25rem; margin-bottom: 1.5rem; color: var(--text-primary); text-align: center;
        }
        .about-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            box-shadow: 0 4px 6px -1px var(--shadow-color);
            cursor: grab;
            user-select: none; /* Prevent text selection while dragging */
            position: relative; /* Start relative */
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Keep hover effect transition */
            /* Ensure initial position is not affected by drag styles */
            left: auto;
            top: auto;
        }
        .about-card:hover {
            /* Keep hover effect only when not dragging */
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px var(--shadow-color);
        }
        .about-card h3 {
            font-size: 0.9rem; font-weight: 600; color: var(--accent-primary); margin-bottom: 0.5rem;
        }
        .about-card p { color: var(--text-secondary); font-size: 0.8rem; line-height: 1.4; }
        .about-card code {
            background-color: var(--accent-secondary);
            padding: 0.1rem 0.3rem; border-radius: 0.25rem; font-size: 0.8em;
            color: var(--accent-primary);
        }
        .dark .about-card code { color: var(--text-primary); }

        .dragging {
            position: absolute; /* Switch to absolute for dragging */
            cursor: grabbing;
            opacity: 0.85; /* Slightly less transparent */
            z-index: 1000; /* Ensure dragged card is on top */
            box-shadow: 0 10px 20px -3px rgba(0,0,0,0.2);
            transition: none; /* Disable transitions while dragging */
            transform: scale(1.02); /* Slight scale */
        }
        .dragging:hover {
             /* Disable hover transform/shadow while dragging */
             transform: scale(1.02);
             box-shadow: 0 10px 20px -3px rgba(0,0,0,0.2);
        }
        .dark .dragging, .dark .dragging:hover {
             box-shadow: 0 10px 20px -3px rgba(255,255,255,0.2);
        }


        .github-button svg { fill: currentColor; }
        .header-icon { color: var(--text-secondary); }
        .header-icon:hover { color: var(--accent-primary); }
    </style>
</head>
<body class="bg-[--bg-primary] text-[--text-primary] min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-lg space-y-6">

        <!-- Header -->
        <header class="flex justify-between items-center">
            <h1 class="text-xl font-semibold text-[--text-primary]">
                Fingerprint Blood Group AI ðŸ©¸
            </h1>
            <button id="themeToggle" aria-label="Toggle dark mode" class="p-2 rounded-md hover:bg-[--accent-secondary]">
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 header-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 18a6 6 0 100-12 6 6 0 000 12z" />
                </svg>
                 <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 header-icon hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                   <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                 </svg>
            </button>
        </header>

        <!-- Prediction Section -->
        <div class="content-section space-y-4">
             <p class="text-[--text-secondary] text-sm">
                 Upload a fingerprint image to predict the blood group using the AI model running in your browser.
             </p>
             <div>
                 <label for="imageFile" class="text-sm font-medium text-[--text-primary] mb-2 block">Fingerprint Image:</label>
                 <label for="imageFile" class="file-upload-wrapper block rounded-md p-4 text-center">
                     <span class="file-upload-text block text-xs font-medium" id="fileUploadText">
                         Click or drag image here
                     </span>
                     <input type="file" id="imageFile" accept="image/*" required>
                 </label>
             </div>
             <img id="imagePreview" src="#" alt="Preview" class="w-24 h-24 object-cover mx-auto rounded-md border border-[--border-color] bg-[--bg-primary] hidden mt-3"/>
             <button id="predictButton" disabled class="w-full justify-center mt-4 py-2">
                 Predict
                 <span id="loader" class="loader hidden"></span>
             </button>
             <div id="messageBox" class="hidden mt-4 p-2.5 rounded-md text-sm"></div>
             <div id="result" class="mt-5 text-center text-lg font-medium text-[--text-primary]"></div>
        </div>

        <!-- How It Works Section (Draggable Cards) -->
        <div class="content-section about-section">
            <h2 class="text-xl font-semibold text-[--text-primary] mb-4">How It Works (Drag Cards)</h2>
            <div id="howItWorksGrid" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <!-- Cards -->
                <div class="about-card draggable" id="card-1">
                    <h3>1. Data Source</h3>
                    <p>Trained on Kaggle's "Finger Print Based Blood Group Dataset" with labels like <code>A+</code>, <code>B-</code>, etc.</p>
                </div>
                 <div class="about-card draggable" id="card-2">
                    <h3>2. Model Creation</h3>
                    <p>A CNN built with TensorFlow/Keras (<code>Conv2D</code>, <code>MaxPool</code>, <code>Dropout</code>, <code>Dense</code>).</p>
                 </div>
                 <div class="about-card draggable" id="card-3">
                    <h3>3. Image Handling</h3>
                    <p>Images resized to <code>64x64px</code> and pixel values normalized (0-1 range).</p>
                 </div>
                 <div class="about-card draggable" id="card-4">
                    <h3>4. Training</h3>
                    <p>Learned using Adam optimizer and crossentropy loss. Best model saved (<code>.h5</code>).</p>
                 </div>
                 <div class="about-card draggable" id="card-5">
                    <h3>5. Browser Conversion</h3>
                    <p><code>.h5</code> converted to TensorFlow.js format (<code>model.json</code> + <code>.bin</code>) via converter tool.</p>
                 </div>
                 <div class="about-card draggable" id="card-6">
                    <h3>6. Web Interface</h3>
                    <p>HTML, Tailwind CSS, JS. TensorFlow.js runs prediction locally in your browser.</p>
                 </div>
            </div>
        </div>

         <!-- Footer -->
         <footer class="text-center text-xs text-[--text-secondary] pt-4 pb-2">
            <p>Created by [Your Name Here]</p> <!-- Placeholder -->
            <a href="[Your GitHub Repo Link Here]" target="_blank" rel="noopener noreferrer" class="github-button inline-flex items-center space-x-1 text-[--text-secondary] hover:text-[--accent-primary] mt-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-github" viewBox="0 0 16 16">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8"/>
                </svg>
                <span>View on GitHub</span>
             </a>
         </footer>
    </div>

    <!-- Offscreen canvas for processing -->
    <canvas id="offscreenCanvas" width="64" height="64" style="display:none;"></canvas>

    <script>
        // --- DOM Elements ---
        const imageFileInput = document.getElementById('imageFile');
        const predictButton = document.getElementById('predictButton');
        const imagePreview = document.getElementById('imagePreview');
        const resultDiv = document.getElementById('result');
        const messageBox = document.getElementById('messageBox');
        const loader = document.getElementById('loader');
        const fileUploadText = document.getElementById('fileUploadText');
        const offscreenCanvas = document.getElementById('offscreenCanvas');
        const ctx = offscreenCanvas.getContext('2d');
        const themeToggleButton = document.getElementById('themeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const htmlElement = document.documentElement;
        const howItWorksGrid = document.getElementById('howItWorksGrid');

        // --- State ---
        let model = null;
        let imageFile = null;
        const modelPath = './tfjs_model/model.json'; // Relative path to the model JSON
        const CLASS_NAMES = ['A+', 'A-', 'AB+', 'AB-', 'B+', 'B-', 'O+', 'O-'];
        const IMG_SIZE = 64;

        // --- Draggable Card State ---
        let draggedCard = null;
        let isDragging = false;
        let currentX, currentY, targetX, targetY;
        let animationFrameId = null;
        const dampingFactor = 0.2; // How fast the card follows the mouse (0-1, smaller is slower)
        let cardStartX, cardStartY; // Card's initial offset in the grid
        let mouseStartX, mouseStartY; // Mouse position when drag starts relative to page

        // --- Theme Toggle Logic ---
        function applyTheme(isDark) {
            if (isDark) {
                htmlElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                htmlElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
        }
        themeToggleButton.addEventListener('click', () => {
            const isDarkMode = htmlElement.classList.toggle('dark');
            localStorage.theme = isDarkMode ? 'dark' : 'light';
            applyTheme(isDarkMode);
        });
        applyTheme(localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches));


        // --- Load Model & Init Draggable Cards on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadModel();
            initializeDraggableCards();
        });

        // --- Event Listeners ---
        imageFileInput.addEventListener('change', handleImageFile);
        predictButton.addEventListener('click', predict);

        // --- File Handling ---
        function handleImageFile(event) {
            imageFile = null;
            const file = event.target.files[0];
            if (file) {
                imageFile = file;
                fileUploadText.textContent = file.name;
                const reader = new FileReader();
                reader.onload = function(e) {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                     showMessage('Image selected.', 'info');
                }
                reader.readAsDataURL(file);
            } else {
                imagePreview.style.display = 'none';
                imagePreview.src = '#';
                fileUploadText.textContent = 'Click or drag image here';
                 showMessage('Please select an image file.', 'error');
            }
             checkEnableButton();
        }
        function checkEnableButton() {
            predictButton.disabled = !(model && imageFile);
            if (!(model && imageFile)) {
                 resultDiv.textContent = '';
            }
        }

        // --- TensorFlow.js Logic ---
        async function loadModel() {
            setLoading(true, 'Loading AI model...');
            try {
                model = await tf.loadLayersModel(modelPath);
                showMessage('Model loaded! Upload an image.', 'success');
                checkEnableButton();
            } catch (error) {
                console.error("Error loading model:", error);
                showMessage(`Model load error. Check console.`, 'error');
                model = null;
                checkEnableButton();
            } finally {
                setLoading(false);
            }
        }
       async function preprocessImage(imgFile) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            const tensor = tf.browser.fromPixels(img)
                                .resizeBilinear([IMG_SIZE, IMG_SIZE])
                                .toFloat()
                                .div(tf.scalar(255.0))
                                .expandDims();
                            resolve(tensor);
                        } catch (preprocessError) {
                            reject(new Error(`Image processing error.`));
                        }
                    };
                    img.onerror = (err) => reject(new Error("Image load error."));
                    img.src = event.target.result;
                };
                reader.onerror = (err) => reject(new Error("File read error."));
                reader.readAsDataURL(imgFile);
            });
        }
        async function predict() {
            if (!model || !imageFile) {
                showMessage('Please select an image.', 'error');
                return;
            }
            setLoading(true, 'Analyzing...');
            resultDiv.innerHTML = '';
            let tensor;
            try {
                tensor = await preprocessImage(imageFile);
                const predictionTensor = model.predict(tensor);
                const predictedIndex = tf.argMax(predictionTensor, 1).dataSync()[0];
                const predictedClass = CLASS_NAMES[predictedIndex];
                resultDiv.innerHTML = `Predicted: <span>${predictedClass}</span>`;
                showMessage('Analysis complete!', 'success');
                predictionTensor.dispose();
            } catch (error) {
                console.error("Prediction error:", error);
                showMessage(`Analysis failed: ${error.message}`, 'error');
            } finally {
                if (tensor) tensor.dispose();
                setLoading(false);
            }
        }


        // --- UI Helpers ---
        function setLoading(isLoading, message = '') {
            const isInitialLoad = !model && isLoading;
            if (isLoading) {
                if (!isInitialLoad) predictButton.disabled = true;
                loader.classList.remove('hidden');
                 showMessage(message, 'info');
            } else {
                loader.classList.add('hidden');
                checkEnableButton();
            }
        }
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = `messageBox mt-4 p-2.5 rounded-md text-sm ${type}`;
            messageBox.classList.remove('hidden');
        }


        // --- Drag and Drop (Image Upload) ---
         const fileUploadWrapper = document.querySelector('.file-upload-wrapper');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileUploadWrapper.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        ['dragenter', 'dragover'].forEach(eventName => {
            fileUploadWrapper.addEventListener(eventName, () => fileUploadWrapper.classList.add('border-[--accent-primary]', 'bg-opacity-75', 'dark:bg-opacity-25'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            fileUploadWrapper.addEventListener(eventName, () => fileUploadWrapper.classList.remove('border-[--accent-primary]', 'bg-opacity-75', 'dark:bg-opacity-25'), false);
        });
        fileUploadWrapper.addEventListener('drop', handleDrop, false);
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                imageFileInput.files = files;
                const changeEvent = new Event('change');
                imageFileInput.dispatchEvent(changeEvent);
            }
        }


        // --- Draggable Cards Logic (Improved) ---
        function initializeDraggableCards() {
            const draggableCards = document.querySelectorAll('.draggable');
            draggableCards.forEach(card => {
                card.addEventListener('mousedown', startDrag);
                card.addEventListener('dragstart', (e) => e.preventDefault()); // Prevent native drag
            });
        }

        function startDrag(e) {
            if (e.button !== 0 || isDragging) return; // Only left button, prevent multi-drag

            draggedCard = e.currentTarget;
            isDragging = true;

            const cardRect = draggedCard.getBoundingClientRect();
            const gridRect = howItWorksGrid.getBoundingClientRect();

            // Card's initial offset *within the grid*
            cardStartX = cardRect.left - gridRect.left;
            cardStartY = cardRect.top - gridRect.top;

            // Mouse position relative to the page when drag starts
            mouseStartX = e.pageX;
            mouseStartY = e.pageY;

            // Offset of mouse pointer *within the card* (for centering)
            const mouseOffsetX = e.clientX - cardRect.left;
            const mouseOffsetY = e.clientY - cardRect.top;

            // Calculate target position to center card under mouse initially, relative to grid
            targetX = e.clientX - gridRect.left - (cardRect.width / 2);
            targetY = e.clientY - gridRect.top - (cardRect.height / 2);


            // Set initial absolute position and styles
            draggedCard.style.position = 'absolute';
            draggedCard.style.left = `${targetX}px`;
            draggedCard.style.top = `${targetY}px`;
            draggedCard.style.width = `${cardRect.width}px`; // Fix width
            draggedCard.classList.add('dragging');

            currentX = targetX; // Start smoothing from the centered position
            currentY = targetY;

            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('mouseleave', endDrag);

            // Start the smooth animation loop
            cancelAnimationFrame(animationFrameId); // Cancel any previous loop
            animationFrameId = requestAnimationFrame(updatePositionLoop);
        }

        function dragMove(e) {
            if (!isDragging || !draggedCard) return;

            preventDefaults(e); // Prevent text selection, etc.

            const gridRect = howItWorksGrid.getBoundingClientRect();

            // Calculate the mouse's total displacement since drag started
            const mouseDeltaX = e.pageX - mouseStartX;
            const mouseDeltaY = e.pageY - mouseStartY;

            // Calculate the target position based on initial card position + mouse displacement
            // This version follows the mouse directly (target calculation)
            // targetX = cardStartX + mouseDeltaX;
            // targetY = cardStartY + mouseDeltaY;

             // Calculate target position to keep card centered under mouse (target calculation)
             const cardRect = draggedCard.getBoundingClientRect(); // Get current width/height
             targetX = e.clientX - gridRect.left - (cardRect.width / 2);
             targetY = e.clientY - gridRect.top - (cardRect.height / 2);

        }

        function updatePositionLoop() {
            if (!isDragging || !draggedCard) return;

            // Calculate difference between current and target
            const dx = targetX - currentX;
            const dy = targetY - currentY;

            // Apply damping (move a fraction of the distance)
            currentX += dx * dampingFactor;
            currentY += dy * dampingFactor;

            // Update the card's style
            draggedCard.style.left = `${currentX}px`;
            draggedCard.style.top = `${currentY}px`;

            // Continue the loop
            animationFrameId = requestAnimationFrame(updatePositionLoop);
        }

        function endDrag(e) {
            if (!isDragging || !draggedCard) return;

            isDragging = false;
            cancelAnimationFrame(animationFrameId);

            draggedCard.classList.remove('dragging');
            // Keep absolute positioning where it dropped
            // Optional: Add logic here to snap back or reorder grid items
            draggedCard.style.width = ''; // Reset fixed width if needed

            draggedCard = null;

            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('mouseleave', endDrag);
        }

    </script>
</body>
</html>

